import math
from pickle import loads, dumps
import numpy as np
from discretesampling.base.random import RNG
from discretesampling.base.kernel import DiscreteVariableOptimalLKernel


class DiscreteVariable:
    """Base class representing discrete variables.
    """

    def __init__(self):
        pass

    @classmethod
    def getProposalType(self):
        return DiscreteVariableProposal

    @classmethod
    def getTargetType(self):
        return DiscreteVariableTarget

    @classmethod
    def getLKernelType(self):
        # Forward proposal
        return self.getProposalType()

    @classmethod
    def getOptimalLKernelType(self):
        return DiscreteVariableOptimalLKernel

    @classmethod
    def encode(self, x: 'DiscreteVariable') -> np.ndarray:
        encoded = np.array(bytearray(dumps(x)))
        return encoded

    @classmethod
    def decode(self, x: np.ndarray, particle: 'DiscreteVariable') -> list:
        pickle_stopcode = 0x2e
        end_of_pickle_data = np.argwhere(x == pickle_stopcode)[-1][0] + 1
        encoded = np.array(x[0:end_of_pickle_data], dtype=np.uint8)
        decoded = loads(bytes(encoded))
        return decoded


class DiscreteVariableProposal:
    """Base class representing proposal distribution over DiscreteVariables

    """

    def __init__(self, values: list[DiscreteVariable], probs: list[float], rng: RNG = RNG()):
        """Constructor

        Parameters
        ----------
        values : list[DiscreteVariable]
            _description_
        probs : list[float]
            _description_
        rng : RNG, optional
            _description_, by default RNG()
        """
        # Check dims and probs are valid
        assert len(values) == len(probs), "Invalid PMF specified, x and p" +\
            " of different lengths"
        probs = np.array(probs)
        tolerance = np.sqrt(np.finfo(np.float64).eps)
        assert abs(1 - sum(probs)) < tolerance, "Invalid PMF specified," +\
            " sum of probabilities !~= 1.0"
        assert all(probs > 0), "Invalid PMF specified, all probabilities" +\
            " must be > 0"
        self.x = values
        self.pmf = probs
        self.cmf = np.cumsum(probs)
        self.rng = rng

    @classmethod
    def norm(self, x: DiscreteVariable) -> float:
        """_summary_

        Parameters
        ----------
        x : DiscreteVariable
            _description_

        Returns
        -------
        float
            _description_
        """
        return 1.0

    @classmethod
    def heuristic(self, x: DiscreteVariable, y: DiscreteVariable) -> bool:
        """_summary_

        Parameters
        ----------
        x : DiscreteVariable
            _description_
        y : DiscreteVariable
            _description_

        Returns
        -------
        bool
            _description_


        Notes
        -----
        Should return true if proposal is possible between x and y (and possibly at other times) where x and y are
        norm values generated by `norm`
        """
        return True

    def sample(self, target: 'DiscreteVariableTarget' = None) -> DiscreteVariable:
        """_summary_

        Parameters
        ----------
        target : DiscreteVariableTarget, optional
            _description_, by default None

        Returns
        -------
        DiscreteVariable
            _description_
        """
        q = self.rng.random()  # random unif(0,1)
        return self.x[np.argmax(self.cmf >= q)]

    def eval(self, y, target: 'DiscreteVariableTarget' = None) -> float:
        """_summary_

        Parameters
        ----------
        y : _type_
            _description_
        target : DiscreteVariableTarget, optional
            _description_, by default None

        Returns
        -------
        float
            _description_
        """
        try:
            i = self.x.index(y)
            logp = math.log(self.pmf[i])
        except ValueError:
            print("Warning: value " + str(y) + " not in pmf")
            logp = -math.inf
        return logp


# Exact same as proposal above
class DiscreteVariableInitialProposal():
    """_summary_
    """

    def __init__(self, values, probs):
        """_summary_

        Parameters
        ----------
        values : _type_
            _description_
        probs : _type_
            _description_
        """
        # Check dims and probs are valid
        assert len(values) == len(probs), "Invalid PMF specified, x and p" +\
            " of different lengths"
        probs = np.array(probs)
        tolerance = np.sqrt(np.finfo(np.float64).eps)
        assert abs(1 - sum(probs)) < tolerance, "Invalid PMF specified," +\
            " sum of probabilities !~= 1.0"
        assert all(probs > 0), "Invalid PMF specified, all probabilities" +\
            " must be > 0"
        self.x = values
        self.pmf = probs
        self.cmf = np.cumsum(probs)

    def sample(self, rng: RNG = RNG(), target: 'DiscreteVariableTarget' = None) -> DiscreteVariable:
        """_summary_

        Parameters
        ----------
        rng : RNG, optional
            _description_, by default RNG()
        target : DiscreteVariableTarget, optional
            _description_, by default None

        Returns
        -------
        DiscreteVariable
            _description_
        """
        q = rng.random()  # random unif(0,1)
        return self.x[np.argmax(self.cmf >= q)]

    def eval(self, y: DiscreteVariable, target: 'DiscreteVariableTarget' = None) -> float:
        """_summary_

        Parameters
        ----------
        y : DiscreteVariable
            _description_
        target : DiscreteVariableTarget, optional
            _description_, by default None

        Returns
        -------
        float
            _description_
        """
        try:
            i = self.x.index(y)
            logp = math.log(self.pmf[i])
        except ValueError:
            print("Warning: value " + str(y) + " not in pmf")
            logp = -math.inf
        return logp


class DiscreteVariableTarget:
    """Base class representing target (or posterior) distributions for
    DiscreteVariables.
    """

    def __init__(self):
        pass

    def eval(self, x: DiscreteVariable) -> float:
        """Evaluate the target distribution.

        Parameters
        ----------
        x : DiscreteVariable
            value at which the target distribution should be evaluated

        Returns
        -------
        float
           log-probability of target distribution at value `x`
        """
        logprob = -math.inf
        logPrior = self.evaluatePrior(x)
        logprob += logPrior
        return logprob

    def evaluatePrior(self, x: DiscreteVariable) -> float:
        logprob = -math.inf
        return logprob
